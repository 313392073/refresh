变量赋值
    第一： 编译器声明一个变量（如果先前没有在当前作用域中申明过）
    第二：引擎在作用域中查询这个变量并给它赋值 

嵌套作用域
    作用域是通过标识符名称查询变量的一组规则 但是通常会有多余一个作用域需要考虑
就像一个代码块或函数被嵌套在另一个代码块或者函数中一样 作用域被嵌套在其他的作用域中
所以 如果直接在作用域中找不到一个变量的话 引擎就会咨询下一个外层作用域 如此 继续找到
这个变量或者到达外层作用域（全局作用域）

遍历嵌套 作用域的简单规则：
    引擎从当前执行的作用域开始  在那里查找变量  如果没有找到 就向上走一级继续查找
    如此类推  如果找到了最外层的全局作用域 那么查找就会停止  无论它是否找到了变量

this 不会以任何方式指向函数的词法作用域 作用域好像是一个将所有可用标识符作为属性的对象
这从内部来说是对的  但是js 代码不能访作用域对象 他是引擎的内部实现

tips  this
    this 不是编写时绑定  二十运行时绑定  它依赖函数调用的上下文 this绑定与函数声明的位置没有任何关系 而与函数被调用的方式紧密联系
    this实际上是在函数被调用时建立的一个绑定  他指向什么是完全由函数被调用的调用点来决定的

调用点：
    为了理解this绑定  我们不得不理解调用点： 函数在代码中被调用的位置而不是声明的位置
    一般来说 寻找调用点就是  找到一个函数在哪里被调用的 

浏览器查看调用点：
    在函数调用的开始插入debugger语句  当运行整个网页时 调试工具将会停止在这个位置 并且向你展示一个到达
    这一行之前所有被调用过的函数列表 这就是你的调用栈 所以如果你想调查this绑定  可以使用开发者工具取得调用栈
    之后从上向下找到第二个记录 这就是真正的调用点  如果只有一个  那就是window 调用的或者说是自己调用的

new 的操作
    1 一个全新的对象会凭空创建（就是被构建）
    2 这个新构建的对象会被接入原型链
    3 这个新构建的对象被设置为函数调用的this绑定
    4 除非函数返回一个他自己的其他对象，否则这个被new调用的函数将自动返回这个新构建的对象

优先级顺序：
    明确绑定 的优先权高于 隐含绑定 这意味着你应当在考察隐含绑定之前首先考察 明确绑定 是否使用
    new绑定 的优先级要高于 隐含绑定 


对象： 声明形式和构造形式
    一个对象的字面量语法看起来如此
    var obj = {
        key:value
    }
    构造形式如此
    var myObj = new Object()
    myObj.key = value

属性（property） 和方法（method）
    有些开发者喜欢在讨论对一个对象的属性访问时做一个区别 如果这个被访问的值恰好是一个函数的话
因为这个诱使人们认为函数 属于这个对象 而在其他语言中 属于对象（也就是"类"）的函数被称作"方法"
所以相对"属性访问" 我们常能听到"方法访问"

函数绝不会"属于"对象  所以  说一个偶然在对象的引用上被访问的函数就自动地成为了一个"方法" 看起来是牵强附会

有些函数内部确实拥有this 引用 而且有时这些this 引用指向调用点的对象引用 
但这个用法确实没有使这个函数比其他函数更像"方法" 因为this 是在运行时在调用点动态绑定的 这使得它与这个对象的关系至多是间接的

浅拷贝： 会得到一个新的对象 （简单的数据类型 就是单纯的赋值 Object.assign(target,{},{})
深拷贝：是一个引用 他们指向被拷贝对象中引用的相同位置

